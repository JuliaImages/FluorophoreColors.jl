var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"api/#Type-hierarchy-and-construction","page":"Reference","title":"Type hierarchy and construction","text":"","category":"section"},{"location":"api/","page":"Reference","title":"Reference","text":"AbstractMultiChannelColor\nMultiChannelColor\nColorMixture\nGreenMagenta\nMagentaGreen","category":"page"},{"location":"api/#MultiChannelColors.AbstractMultiChannelColor","page":"Reference","title":"MultiChannelColors.AbstractMultiChannelColor","text":"AbstractMultiChannelColor{T<:Number,N}\n\nAn abstract type for multichannel/multiband/hyperspectral colors. Concrete derived types should have a field, channels, which is a NTuple{N,T}. The channels can be returned with Tuple(c::AbstractMultiChannelColor).\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiChannelColors.MultiChannelColor","page":"Reference","title":"MultiChannelColors.MultiChannelColor","text":"MultiChannelColor(i₁, i₂, ...)\nMultiChannelColor((i₁, i₂, ...))\nMultiChannelColor{T}(...)                # coerce to element type T\n\nRepresent multichannel \"raw\" colors, which lack convert methods to standard color spaces. If c is a MultiChannelColor object, then Tuple(c) is a tuple of intensities (one per channel).\n\nColorMixture is an alternative with a built-in conversion to RGB.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiChannelColors.ColorMixture","page":"Reference","title":"MultiChannelColors.ColorMixture","text":"ColorMixture((rgb₁, rgb₂, ...), (i₁, i₂, ...))\nColorMixture((rgb₁, rgb₂, ...), i₁, i₂, ...)\nColorMixture{T}(...)                       # coerce intensities to element type\n\nRepresent a multichannel color with a defined conversion to RGB. rgbⱼ is an RGB color corresponding to channel j, and its intensity is iⱼ. Colors are converted to RGB, convert(RGB, c), using intensity-weighting: rgb = sum(ivalues .* rgbvalues).\n\nMultiChannelColor is an alternative that does not require an rgb list and has no built-in conversion to RGB.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiChannelColors.GreenMagenta","page":"Reference","title":"MultiChannelColors.GreenMagenta","text":"GreenMagenta{T}(intensities)\nGreenMagenta(intensities)\n\nConstruct a ColorMixture with the specified intensities that colorizes the first channel with green and the second with magenta.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiChannelColors.MagentaGreen","page":"Reference","title":"MultiChannelColors.MagentaGreen","text":"MagentaGreen{T}(intensities)\nMagentaGreen(intensities)\n\nConstruct a ColorMixture with the specified intensities that colorizes the first channel with magenta and the second with green.\n\n\n\n\n\n","category":"type"},{"location":"api/#Fluorophores","page":"Reference","title":"Fluorophores","text":"","category":"section"},{"location":"api/","page":"Reference","title":"Reference","text":"fluorophore_rgb\n@fluorophore_rgb_str","category":"page"},{"location":"api/#MultiChannelColors.fluorophore_rgb","page":"Reference","title":"MultiChannelColors.fluorophore_rgb","text":"rgb = fluorophore_rgb[name]\n\nLook up the RGB color associated with a fluorophore named name.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MultiChannelColors.@fluorophore_rgb_str","page":"Reference","title":"MultiChannelColors.@fluorophore_rgb_str","text":"rgb = fluorophore_rgb\"NAME\"\n\nLook up the RGB color associated with a fluorophore hard-coded in the string that follows. This lookup is performed at compile-time, and hence the value of rgb is visible to the compiler and may be constant-propagated.\n\nIf the fluorophore name cannot be hard-coded, use the dictionary form fluorophore_rgb[name].\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiChannelColors","category":"page"},{"location":"#MultiChannelColors","page":"Home","title":"MultiChannelColors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiChannelColors aims to support \"unconventional colors,\" such as might arise in applications like multichannel fluorescence microscopy and hyperspectral imaging. Consistent with the philosophy of the JuliaImages ecosystem, this package allows you to bundle together the different color channels into a \"color object,\" and many color objects can be stored in an array. Having each entry of the array represent a complete pixel or voxel makes it much easier to write generic code supporting a wide range of image types.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the package with add MultiChannelColors from the pkg> prompt, which you access by typing ] from the julia> prompt. See the Pkg documentation for more information.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use the package interactively or in code with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MultiChannelColors","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to giving access to specific types defined below, this will import the namespaces of FixedPointNumbers (which harmonizes the interpretation of \"integer\" and \"floating-point\" pixel-encodings) and ColorTypes (which defines core color types and low-level manipulation). It will also define arithmetic for colors such as RGB (see ColorVectorSpace).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The color types in this package support two fundamental categories of operations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"arithmetic operations such as + and - and multiplying or dividing by a scalar. You can also scale each color channel independently with ⊙ (obtained with \\odot<tab>) or its synonym hadamard, e.g., g ⊙ c where c is a color object defined in this package and g is a tuple of real numbers (the \"gains\").\nextracting the independent channel intensities as a tuple with Tuple(c).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When creating c, you have two choices which primarily affect visualization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"to use \"bare\" colors that store the multichannel data but lack any default conversion to other color spaces. This might be most appropriate if you have more than 3 channels, for which there may be many different ways to visualize the data they encode.\nto use colors with built-in conversion to RGB, making them work automatically in standard visualization tools. This may be most appropriate when you have 3 or fewer channels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both options will be discussed below. See the JuliaImages documentation on visualization for more information about tools for viewing images.","category":"page"},{"location":"#index_multichannelcolor","page":"Home","title":"\"Bare\" colors: MultiChannelColor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A MultiChannelColor object is essentially a glorified tuple, one that can be recognized as a Colorant but with comparatively few automatic behaviors. For example, if you're working with Landsat 8 data with 11 wavelength bands, one might create a pixel this way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> c = MultiChannelColor{N4f12}(0.2, 0.1, 0.2, 0.2, 0.25, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2)\n(0.2N4f12₀₁, 0.1001N4f12₀₂, 0.2N4f12₀₃, 0.2N4f12₀₄, 0.2501N4f12₀₅, 0.2N4f12₀₆, 0.2N4f12₀₇, 0.2N4f12₀₈, 0.2N4f12₀₉, 0.2N4f12₁₀, 0.2N4f12₁₁)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the FixedPointNumbers package for information about the 16-bit data type N4f12 (Landsat 8 quantizes with 12 bits).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The usual way to visualize such an object is to define a custom function that converts such colors to more conventional colors (RGB or Gray). For example, we might compute the Enhanced Vegetation Index and render positive values in green and negative values in magenta:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> function evi(c::MultiChannelColor{T,11}) where T<:FixedPoint\n           # Valid for Landsat 8 with 11 spectral bands\n           b = Tuple(c)                      # extract the bands\n           evi = 2.5f0 * (b[5] - b[4]) / (b[5] + 6*b[4] - 7.5f0*b[2] + eps(T))\n           return evi > 0 ? RGB(0, evi, 0) : RGB(-evi, 0, -evi)\n       end;\n\njulia> evi(c)\nRGB{Float32}(0.0f0,0.17894554f0,0.0f0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If img is a whole image of such pixels, evi.(img) converts the entire array to RGB. For large data, you might prefer to use the MappedArrays package to do such conversions \"lazily\" (on an as-needed basis) to avoid exhausting computer memory:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MappedArrays\n\njulia> imgrgb = mappedarray(evi, img);","category":"page"},{"location":"#index_colormixture","page":"Home","title":"RGB-convertible colors: ColorMixture","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ColorMixture objects are like MultiChannelColor objects except they have a built-in conversion to RGB. Each channel gets assigned a specific RGB color, say rgbⱼ for the jth channel, along with an intensity iⱼ. rgbⱼ is a feature of the type (shared by all objects of the same type) whereas iⱼ is a property of objects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ColorMixture objects are converted to RGB with intensity-weighting,","category":"page"},{"location":"","page":"Home","title":"Home","text":"c_rgb = sum_j i_j mathrmrgb_j","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depending on the the rgbⱼ and iⱼ, values may exceed the 0-to-1 colorscale of RGBs. Conversion to RGB{Float32} may be safer than RGB{T} where T is limited to 0-to-1. It is also faster, as the result does not have to be checked for whether it exceeds the bounds of the type. (To prevent overflow, all internal operations are performed using floating-point intermediates even if you want a FixedPoint output.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nWhile ColorMixture objects can be converted to RGB, they are not AbstractRGB colors: red(c), green(c), and blue(c) are not defined for c::ColorMixture, and low-level utilities like mapc operate on the raw channel intensities rather than the RGB values.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are several ways you can create these colors. An easy approach is to define the type through a \"template\" object:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ctemplate = ColorMixture{Float32}((RGB(0,1,0), RGB(1,0,0)))\n(0.0₁, 0.0₂)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ctemplate is an all-zeros ColorMixture object, but can be used to construct arbitrary c with specified intensities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> typeof(ctemplate)\nColorMixture{Float32, 2, (RGB{N0f8}(0.0,1.0,0.0), RGB{N0f8}(1.0,0.0,0.0))}\n\njulia> c = ctemplate(0.2, 0.4)\n(0.2₁, 0.4₂)\n\njulia> Tuple(c)\n(0.2f0, 0.4f0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also create them with a single call ColorMixture(rgbs, intensities):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> c = ColorMixture{Float32}((RGB(0,1,0), RGB(1,0,0)), (0.2, 0.4))\n(0.2₁, 0.4₂)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or even by explicit type construction:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ColorMixture{Float32, 2, (RGB{N0f8}(0.0,1.0,0.0), RGB{N0f8}(1.0,0.0,0.0))}(0.2, 0.4)\n(0.2₁, 0.4₂)","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nAll but the last form require constant propagation for inferrability. Julia 1.7 and higher can use \"aggressive\" constant propagation to solve inference problems that may reduce performance on Julia 1.6.","category":"page"},{"location":"#Importing-external-data","page":"Home","title":"Importing external data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When objects are not created by code but instead loaded from an external source such as a file, you have several avenues for creating arrays of multichannel color objects. There are two particularly common cases:","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the imported data are an array A of size (nc, m, n), where nc is the number of color channels (i.e., color is the fastest dimension), then use reinterpret(reshape, C, A) where C is the color type you want to use (e.g., MultiChannelColor{T,nc} or ColorMixture{T,nc,rgbs}). For instance, Landsat 8 data might look something like this:\nA = rand(0x0000:0x0fff, 11, 100, 100);\nimg = reinterpret(reshape, MultiChannelColor{N4f12,11}, A);\nIf the imported data have the color channel last, or use separate arrays for each channel, use the StructArrays package. For example:\nA = rand(0x0000:0x0fff, 100, 100, 11);\nimg = StructArray{MultiChannelColor{N4f12,11}}(A; dims=3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is possible that simpler syntaxes will be developed in future releases.","category":"page"},{"location":"#Additional-features","page":"Home","title":"Additional features","text":"","category":"section"},{"location":"#Fluorophores","page":"Home","title":"Fluorophores","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package also exports a lookup table for common fluorophores. If desired, these can be used as the rgbⱼ values for ColorMixture channels. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> channels = (fluorophore_rgb[\"EGFP\"], fluorophore_rgb[\"tdTomato\"])\n(RGB{N0f8}(0.0,0.925,0.365), RGB{N0f8}(1.0,0.859,0.0))\n\njulia> ctemplate = ColorMixture{N0f16}(channels)\n(0.0N0f16₁, 0.0N0f16₂)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you'll be hard-coding the name of the fluorophore, consider using a slightly different syntax:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> channels = (fluorophore_rgb\"EGFP\", fluorophore_rgb\"tdTomato\")\n(RGB{N0f8}(0.0,0.925,0.365), RGB{N0f8}(1.0,0.859,0.0))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note the absence of [] brackets around the fluorophore names.  This form creates types inferrably, but the fluorophore name must be a literal string constant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The RGB values are computed from the peak emission wavelength of each fluorophore; note, however, that the perceptual appearance is often more red-shifted due to the asymmetric shape of emission spectra.","category":"page"},{"location":"#Green/magenta-coloration","page":"Home","title":"Green/magenta coloration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For good separability in two-color imaging, the GreenMagenta{T} and MagentaGreen{T} types are convenient:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> c = GreenMagenta{N0f8}(0.2, 0.4)\n(0.2N0f8₁, 0.4N0f8₂)\n\njulia> convert(RGB, c)\nRGB{N0f8}(0.4,0.2,0.4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Green and magenta are distinguishable even by individuals with common forms of color blindness, and is thus a good default for two-color imaging.","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#Why-are-the-RGB-colors-encoded-in-the-ColorMixture-*type*?-Why-not-a-value-field?","page":"FAQ","title":"Why are the RGB colors encoded in the ColorMixture type? Why not a value field?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In many places, JuliaImages assumes that you can convert from one color space to another purely from knowing the type you want to convert to. This would not be possible if the RGB colors were encoded as a second field of the color.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you consider an entire image Array{<:ColorMixture} (the preferred default representation for code in JuliaImages), it becomes clear that storing the RGB colors as a value field would also require additional memory for each pixel.","category":"page"},{"location":"faq/#I-wrote-some-code-and-got-lousy-performance.-How-can-I-fix-it?","page":"FAQ","title":"I wrote some code and got lousy performance. How can I fix it?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To achieve good performance, in some cases the RGB values must be aggressively constant-propagated, a feature available only on Julia 1.7 and higher. So if you're experiencing this problem on Julia 1.6, try a newer version.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you're using fluorophore colors with fluorophore_rgb, where possible make sure you're using the compile-time constant syntax fluorophore_rgb\"EGFP\" rather than the runtime syntax fluorophore_rgb[\"EGFP\"].","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"When you can't get good performance otherwise, your best option is to use a function barrier:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ctemplate = ColorMixture((rgb1, rgb2))\n\n@noinline function make_image_and_do_something(ctemplate, sz)\n    img = [ctemplate(rand(), rand()) for i = 1:sz[1], j = 1:sz[2]]\n    ...\nend","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In this case ctemplate encodes the type, and code in make_image_and_do_something will be inferrable even if the type of the created ctemplate is not inferrable in its creation scope.","category":"page"}]
}
